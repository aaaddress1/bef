---
layout: post
title: "[C++][PEB][ASM]硬幹取得指定函數的內存地址、透過PEB枚舉獲取指定內存地址之函數名稱"
date: '2015-02-16T08:54:00.001-08:00'
author: 聖豪馬
tags:
- CBuilder
- CPlus
- ASM
modified_time: '2015-06-01T04:43:40.397-07:00'
blogger_id: tag:blogger.com,1999:blog-1335849442109808564.post-8929587396336594148
blogger_orig_url: http://helloadr.blogspot.com/2015/02/cpebasmpeb.html
---

這篇是個人筆記啦XD<br />基本上就是因為網路上要找到寫這種奇怪的東西，實在找不到<br />所以就去網路上東抓西抓然後改一改弄出來的東西了<br /><br />首先是<br />透過指定模組取得函數名稱的地址(其實就是GetProcAddress API的功能啦)<br /><br /><pre class="brush: cpp;">DWORD GetFuncAddr(HMODULE hModule,char* FuncName)<br />{<br />PIMAGE_DOS_HEADER pDosHeader;<br />PIMAGE_NT_HEADERS pNtHeader;<br />PIMAGE_EXPORT_DIRECTORY pExportDirectory;<br />HMODULE hModuleBase = hModule;<br />pDosHeader = (PIMAGE_DOS_HEADER)hModuleBase;<br />pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)hModuleBase + pDosHeader-&gt;e_lfanew);<br />pExportDirectory = PIMAGE_EXPORT_DIRECTORY(pNtHeader-&gt;OptionalHeader.DataDirectory[0].VirtualAddress + (PBYTE)hModuleBase);<br />PDWORD pAddressName = PDWORD((PBYTE)hModuleBase+pExportDirectory-&gt;AddressOfNames); //函数名称表指针<br />PWORD pAddressOfNameOrdinals = (PWORD)((PBYTE)hModuleBase+pExportDirectory-&gt;AddressOfNameOrdinals); //函数名称序号表指针<br />PDWORD pAddresOfFunction = (PDWORD)((PBYTE)hModuleBase+pExportDirectory-&gt;AddressOfFunctions); //函数地址表指针<br /> for (int index = 0; index &lt; (pExportDirectory-&gt;NumberOfNames); index++)<br /> {<br />  PCHAR pFunc = (PCHAR)((long)hModuleBase + *pAddressName);<br />  pAddressName ++ ;<br />  if (!strcmp(pFunc, FuncName)) return (DWORD)( (PBYTE)hModuleBase + pAddresOfFunction[*pAddressOfNameOrdinals]);<br />  pAddressOfNameOrdinals++;//ENT和函数名序号数组两个并行数组同时滑动指针(序号数组中的序号就对应函数名对应的函数地址的数组索引)<br /> }<br /> return (NULL);<br />}<br /></pre>再來就是<br />網路上找不太到該怎麼實做的<br />＂從指定函數地址取得函數名稱＂（應該說是GetProcAddress的反函數吧？）<br />實際做法其實就是把上面的暴力枚舉模組的API反過來檢測而已<br /><pre class="brush: cpp;">AnsiString GetFuncName(HMODULE hModule,DWORD FuncAddr)<br />{<br />PIMAGE_DOS_HEADER pDosHeader;<br />PIMAGE_NT_HEADERS pNtHeader;<br />PIMAGE_EXPORT_DIRECTORY pExportDirectory;<br />HMODULE hModuleBase = hModule;<br />pDosHeader = (PIMAGE_DOS_HEADER)hModuleBase;<br />pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)hModuleBase + pDosHeader-&gt;e_lfanew);<br />pExportDirectory = PIMAGE_EXPORT_DIRECTORY(pNtHeader-&gt;OptionalHeader.DataDirectory[0].VirtualAddress + (PBYTE)hModuleBase);<br />PDWORD pAddressName = PDWORD((PBYTE)hModuleBase+pExportDirectory-&gt;AddressOfNames); //函数名称表指针<br />PWORD pAddressOfNameOrdinals = (PWORD)((PBYTE)hModuleBase+pExportDirectory-&gt;AddressOfNameOrdinals); //函数名称序号表指针<br />PDWORD pAddresOfFunction = (PDWORD)((PBYTE)hModuleBase+pExportDirectory-&gt;AddressOfFunctions); //函数地址表指针<br /> for (int index = 0; index &lt; (pExportDirectory-&gt;NumberOfNames); index++)<br /> {<br />  PCHAR pFunc = (PCHAR)((long)hModuleBase + *pAddressName);<br />  pAddressName ++ ;<br />  DWORD CurrentFuncAddr = ( (DWORD)hModuleBase + pAddresOfFunction[*pAddressOfNameOrdinals]) ;<br />  if ( !(CurrentFuncAddr - FuncAddr) )<br />  {<br />   return pFunc;<br />  }<br />  pAddressOfNameOrdinals++;<br /> }<br /> return ("");<br />}<br /></pre>最後就是<br />萬一如果知道內存地址但是不知道它在哪個模組上的時候<br />&nbsp;要馬可以透過VirtualQueryEx取得模組基址<br />但要是VirtualQueryEx沒辦法取得的時候就得透過PEB表暴力列舉所有模組然後去搜索<br /><pre class="brush: cpp;"><br />AnsiString EnumGetFuncName(DWORD FuncAddr)<br />{<br /> MEMORY_BASIC_INFORMATION mbi;<br /> VirtualQueryEx((void*)-1,(void *)FuncAddr,&mbi,sizeof(MEMORY_BASIC_INFORMATION));<br /> if (mbi.BaseAddress && mbi.AllocationBase) return (GetFuncName((HMODULE)mbi.AllocationBase ,FuncAddr));<br /> void *PEB = NULL,<br /> *Ldr = NULL,<br /> *Flink = NULL,<br /> *p = NULL,<br /> *BaseAddress = NULL,<br /> *FullDllName = NULL;<br /> asm<br /> {<br />  mov eax,fs:[0x30]<br />  mov PEB,eax<br /> }<br /> Ldr = *( ( void ** )( ( unsigned char * )PEB+0x0c ) );<br /> Flink = *( ( void ** )( ( unsigned char * )Ldr+ 0x1c ) );<br /> p = Flink;<br /> do<br /> {<br />  BaseAddress = *( ( void ** )( ( unsigned char * )p+ 0x08 ) );<br />  FullDllName = *( ( void ** )( ( unsigned char * )p+ 0x18) );<br />  AnsiString CurrentFoundName = GetFuncName((HMODULE)BaseAddress,FuncAddr);<br />  if (CurrentFoundName != "") return CurrentFoundName ;<br />  p = *( ( void ** )p);<br /> }<br /> while ( Flink != p );<br /> return "";<br />}<br /></pre>