---
layout: post
title: "[C++][ASM]免API撈模組基址(asm從PEB硬幹)"
date: '2015-02-15T03:37:00.001-08:00'
author: 聖豪馬
tags:
- CPlus
- ASM
modified_time: '2015-06-01T04:43:40.373-07:00'
blogger_id: tag:blogger.com,1999:blog-1335849442109808564.post-4251276204121700849
blogger_orig_url: http://helloadr.blogspot.com/2015/02/casmapiasmeb.html
---

這是從對岸忘記從哪裡撈來的...<br />不過看了一下手法很漂亮就記錄下來惹XD<br />原理是用asm從PEB去指向模組的List去找這樣<br />底下稍微改過原本寫法然後補上註解<br /><blockquote class="tr_bq">DWORD GetSelfModule()//等同GetModuleHanle(NULL)<br />{<br />DWORD dRetn = 0;<br />asm<br />{<br />&nbsp; &nbsp;push eax //保護堆疊<br />&nbsp; &nbsp;MOV eax,dword ptr fs:[0x30] // pointer to PEB<br />&nbsp; &nbsp;MOV eax,dword ptr [eax+0x8] //eax = Current Module Base<br />&nbsp; &nbsp;MOV [dRetn],eax<br />&nbsp; &nbsp;pop eax //恢復堆疊<br />}<br />return dRetn;<br />}</blockquote>另個是如果想搜索<br /><blockquote class="tr_bq">DWORD GetKernelModule()//獲取Kernel32 DLL Base<br />{<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>DWORD dRetn = 0;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>asm<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>{<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp;&nbsp; push eax<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp;&nbsp; mov eax,dword ptr fs:[0x30] &nbsp; //pointer to PEB<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp;&nbsp; mov eax,dword ptr [eax+0x0c] &nbsp; //pointer to loader data<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp;&nbsp; mov eax,dword ptr [eax+0x1c] &nbsp; //first entry in initialization order list (ntdll.dll)<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp;&nbsp; mov eax,dword ptr [eax] &nbsp; &nbsp;//second entry int initialization order list (kernel32.dll)<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp;&nbsp; mov eax,dword ptr [eax+0x08] &nbsp; //base addr of kernel32.dll<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp;&nbsp; mov [dRetn],eax<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp;&nbsp; pop eax<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br />return dRetn;<br />}</blockquote>至於可以用在哪.....<br />比如說...要做黑黑的事情但是不想被防毒檢測到之類的XD(?)<br />或者遊戲保護不給搜索(?)不過一般遊戲不會防這個啦<br /><br />忘了補一個<br />看雪的某個大大丟的寫法這個也不錯XD<br /><blockquote class="tr_bq"><blockquote class="tr_bq">//*參考 看雪 【原创】搜索输出表取得GetProcAddress地址C++版</blockquote><blockquote class="tr_bq">PIMAGE_DOS_HEADER pDosHeader;</blockquote><blockquote class="tr_bq">PIMAGE_NT_HEADERS pNtHeader;</blockquote><blockquote class="tr_bq">PIMAGE_EXPORT_DIRECTORY pExportDirectory;</blockquote><blockquote class="tr_bq">HMODULE hModuleBase = hModule;</blockquote><blockquote class="tr_bq">pDosHeader = (PIMAGE_DOS_HEADER)hModuleBase;</blockquote><blockquote class="tr_bq">pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)hModuleBase + pDosHeader-&gt;e_lfanew);</blockquote><blockquote class="tr_bq">pExportDirectory = PIMAGE_EXPORT_DIRECTORY(pNtHeader-&gt;OptionalHeader.DataDirectory[0].VirtualAddress + (PBYTE)hModuleBase);</blockquote><blockquote class="tr_bq">PDWORD pAddressName = PDWORD((PBYTE)hModuleBase+pExportDirectory-&gt;AddressOfNames); //函数名称表指针</blockquote><blockquote class="tr_bq">PWORD pAddressOfNameOrdinals = (PWORD)((PBYTE)hModuleBase+pExportDirectory-&gt;AddressOfNameOrdinals); //函数名称序号表指针</blockquote><blockquote class="tr_bq">//PDWORD pAddresOfFunction = (PDWORD)((PBYTE)hModuleBase+pExportDirectory-&gt;AddressOfFunctions); //函数地址表指针</blockquote><blockquote class="tr_bq"><span class="Apple-tab-span" style="white-space: pre;"> </span>for (int index = 0; index &lt; (pExportDirectory-&gt;NumberOfNames); index++)</blockquote><blockquote class="tr_bq"><span class="Apple-tab-span" style="white-space: pre;"> </span>{</blockquote><blockquote class="tr_bq"><span class="Apple-tab-span" style="white-space: pre;">  </span>PCHAR pFunc = (PCHAR)((long)hModuleBase + *pAddressName);</blockquote><blockquote class="tr_bq"><span class="Apple-tab-span" style="white-space: pre;">  </span>pAddressName ++ ;</blockquote><blockquote class="tr_bq"><span class="Apple-tab-span" style="white-space: pre;">  </span>if (!strcmp(pFunc, "GetProcAddress")) break;</blockquote><blockquote class="tr_bq"><span class="Apple-tab-span" style="white-space: pre;">  </span>pAddressOfNameOrdinals++;//ENT和函数名序号数组两个并行数组同时滑动指针(序号数组中的序号就对应函数名对应的函数地址的数组索引)</blockquote><blockquote class="tr_bq"><span class="Apple-tab-span" style="white-space: pre;"> </span>}</blockquote></blockquote>