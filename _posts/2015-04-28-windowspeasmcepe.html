---
layout: post
title: "[Windows][PE][ASM][CE]從PE架構淺談純組語撈出當前進程的映像路徑"
date: '2015-04-28T12:00:00.000-07:00'
author: 聖豪馬
tags:
- PE
- CheatEngine
- Windows
- ASM
modified_time: '2015-04-29T11:25:27.159-07:00'
thumbnail: http://2.bp.blogspot.com/-DG9Jj2EEubc/VT_VQLRjCpI/AAAAAAAAGR4/MhI7VwktR3s/s72-c/%E6%9C%AA%E5%91%BD%E5%90%8D.png
blogger_id: tag:blogger.com,1999:blog-1335849442109808564.post-4967046379238653034
blogger_orig_url: http://helloadr.blogspot.com/2015/04/windowspeasmcepe.html
---

近日很少發發廢文啊XD，大學生各種忙碌期中考<br />最近觀書有感，來發發拆拆手札廢文<br /><br />參考文獻<br /><ol><li><a href="http://securityalley.blogspot.tw/2013/06/blog-post.html">緩衝區溢位攻擊：第三章 - 改變程式執行的行為</a></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706%28v=vs.85%29.aspx">MSDN - PEB structure</a></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa813741%28v=vs.85%29.aspx">MSDN -&nbsp; RTL_USER_PROCESS_PARAMETERS structure</a></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa380518%28v=vs.85%29.aspx">MSDN - UNICODE_STRING structure</a> </li></ol>懶人包： <br />每個Process中都會存在一個TEB結構體<br />偷偷引用一下文章中的結構：<br /><pre class="brush: cpp;">typedef struct _TEB<br />{<br />        NT_TIB                  Tib;// Offset = 0x00<br />        PVOID                   EnvironmentPointer;<br />        CLIENT_ID               Cid;<br />        PVOID                   ActiveRpcInfo;<br />        PVOID                   ThreadLocalStoragePointer;<br />        PPEB                    Peb;<br />        ULONG                   LastErrorValue;<br />        ULONG                   CountOfOwnedCriticalSections;<br />        PVOID                   CsrClientThread;<br />        PVOID                   Win32ThreadInfo;<br />        ULONG                   Win32ClientInfo[0x1F];<br />        PVOID                   WOW32Reserved;<br />        ULONG                   CurrentLocale;<br />        ULONG                   FpSoftwareStatusRegister;<br />        PVOID                   SystemReserved1[0x36];<br />        PVOID                   Spare1;<br />        ULONG                   ExceptionCode;<br />        ULONG                   SpareBytes1[0x28];<br />        PVOID                   SystemReserved2[0xA];<br />        ULONG                   GdiRgn;<br />        ULONG                   GdiPen;<br />        ULONG                   GdiBrush;<br />        CLIENT_ID               RealClientId;<br />        PVOID                   GdiCachedProcessHandle;<br />        ULONG                   GdiClientPID;<br />        ULONG                   GdiClientTID;<br />        PVOID                   GdiThreadLocaleInfo;<br />        PVOID                   UserReserved[5];<br />        PVOID                   GlDispatchTable[0x118];<br />        ULONG                   GlReserved1[0x1A];<br />        PVOID                   GlReserved2;<br />        PVOID                   GlSectionInfo;<br />        PVOID                   GlSection;<br />        PVOID                   GlTable;<br />        PVOID                   GlCurrentRC;<br />        PVOID                   GlContext;<br />        NTSTATUS                LastStatusValue;<br />        UNICODE_STRING          StaticUnicodeString;<br />        WCHAR                   StaticUnicodeBuffer[0x105];<br />        PVOID                   DeallocationStack;<br />        PVOID                   TlsSlots[0x40];<br />        LIST_ENTRY              TlsLinks;<br />        PVOID                   Vdm;<br />        PVOID                   ReservedForNtRpc;<br />        PVOID                   DbgSsReserved[0x2];<br />        ULONG                   HardErrorDisabled;<br />        PVOID                   Instrumentation[0x10];<br />        PVOID                   WinSockData;<br />        ULONG                   GdiBatchCount;<br />        ULONG                   Spare2;<br />        ULONG                   Spare3;<br />        ULONG                   Spare4;<br />        PVOID                   ReservedForOle;<br />        ULONG                   WaitingOnLoaderLock;<br />        PVOID                   StackCommit;<br />        PVOID                   StackCommitMax;<br />        PVOID                   StackReserved;<br />} TEB, *PTEB; </pre><br />每個Process中的TEB會存放這支Process中運行的環境、Process的屬性、或者大家Coding會用的Try的偵錯機制處理...等，不過今天我要先講的是映像路徑（ImagePath）的擷取，所以現在著重的重點放在Offset = 0x30上的PEB（Process Environment Block）上，裡面會存放許多關於當前進程的屬性資料；而如果是研究BufferOverflow則對Offset = 0x00上的NT_TIB很熟悉了（內含WIN處理錯誤機制屬性處理的資料）<br /><br />那麼今天我們要取的映像路徑會放在哪？查了一下資料會得知放在PEB內的ProcessParameters結構體內的ImagePathName指標（以UnicodeString做存放）<br /><br />參考了一下MSDN上微軟官方對PEB的定義如下：<br /><pre class="brush : cpp;">typedef struct _PEB {<br />  BYTE                          Reserved1[2];//0x00<br />  BYTE                          BeingDebugged;//0x00 + 1 *2 = 0x02<br />  BYTE                          Reserved2[1];//0x02 + 1 = 0x03<br />  PVOID                         Reserved3[2];//0x03 + 1 = 0x04<br />  PPEB_LDR_DATA                 Ldr;//0x04 + 4 *2 = 0x0C<br />  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;//0x0C + 4 = 0x10<br />  BYTE                          Reserved4[104];<br />  PVOID                         Reserved5[52];<br />  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;<br />  BYTE                          Reserved6[128];<br />  PVOID                         Reserved7[1];<br />  ULONG                         SessionId;<br />} PEB, *PPEB;</pre>可以參考一下我補上的Offset，要從PEB結構體爬到ProcessParameters的指標Offset算法會是：BYTE*2 + BYTE + BYTE + PVOID*2 + PPEB_LDA_DATA = 0x10<br /><br />接著可以在參考一下MSDN上的ProcessParameters（在Windows的.h頭文件內定義是_RTL_USER_PROCESS_PARAMETERS）結構體定義：<br /><pre class="brush: cpp;">typedef struct _RTL_USER_PROCESS_PARAMETERS {<br />  BYTE           Reserved1[16];//0x00<br />  PVOID          Reserved2[10];//0x00 + 1 * 16 = 0x10<br />  UNICODE_STRING ImagePathName;//0x10 + 4 * 10 = 0x38<br />  UNICODE_STRING CommandLine;<br />} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;</pre>接著看到這個結構體上我補上的Offset，一路從ProcessParameters結構體爬到ImagePathName指針的Offset就會是 BYTE*16 + PVOID*10 = 0x38<br /><br />所以這邊我用了Cheat Engine的AutoASM寫了一個簡單的彙編腳本：<br /><pre class="brush: cpp;">alloc(Func,128)<br />alloc(GetPtr,4)<br />createthread(Func)<br />registersymbol(GetPtr)<br /><br />Func:<br />mov eax, fs:[30]//eax = fs[30] = PEB_address.<br />mov eax,[eax+10]//eax = fs[30] + ProcessParameters_offset.<br />add eax,38      //eax = ProcessParametersAddress + ImagePath_offset.<br />mov [GetPtr],eax<br />ret</pre>跑起來像這樣；<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-DG9Jj2EEubc/VT_VQLRjCpI/AAAAAAAAGR4/MhI7VwktR3s/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-DG9Jj2EEubc/VT_VQLRjCpI/AAAAAAAAGR4/MhI7VwktR3s/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png" height="304" width="640" /></a></div>&nbsp;這邊我在Win7 x32bit下對記事本(notepad.exe)的進程做鎖定，執行了我寫的腳本後，可以去看到GetPtr取到地址為0x00231A90，這是什麼呢？這就會是UnicodeString的結構了（存放ImagePath文字）<br /><br />可以查一下MSDN上的UNICODE_STRING結構體如下：<br /><pre class="brush:cpp;">typedef struct _LSA_UNICODE_STRING {<br />  USHORT Length;//0x00<br />  USHORT MaximumLength;//0x00 + 2 = 0x02<br />  <b><span style="color: red;">PWSTR  Buffer;//0x02 + 2 = 0x04</span></b><br />} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;<br /></pre>這邊可以得知我們的UncodeString上有兩個Buffer（以Short為單位，意味著其實UncodeString在Windows上最大只能到16*16 = 256單位長）才會是指向文字內容的指針<br /><br />所以我們就可以得知找到文字的指針加上0x04的Offset就可以成功指向文字了<br />操作如下：<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-HcXa45BMx_Y/VT_XNZuYemI/AAAAAAAAGSE/KzmVZTUQS_w/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-HcXa45BMx_Y/VT_XNZuYemI/AAAAAAAAGSE/KzmVZTUQS_w/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png" height="320" width="276" /></a></div>在Cheat Engine介面下新增Pointer，地址填寫GetPtr（或者填寫0x00231A90）然後Offset填寫0x04：<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-DpB04DfRIcE/VT_XhkB3O8I/AAAAAAAAGSM/sejPqaiuoog/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-DpB04DfRIcE/VT_XhkB3O8I/AAAAAAAAGSM/sejPqaiuoog/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png" height="144" width="640" /></a></div>&nbsp;嘿嘿，成功找到ImagePath的結構體上指向的Buffer指針囉，指針地址為0x0023271A<br />接著就可以看到進程的ImagePath存放的路徑囉，如下：<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-L8fVBdoqa80/VT_YGfaf3bI/AAAAAAAAGSU/A5lmoh_U6jY/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-L8fVBdoqa80/VT_YGfaf3bI/AAAAAAAAGSU/A5lmoh_U6jY/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png" height="140" width="640" /></a></div>&nbsp;Got It！