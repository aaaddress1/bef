---
layout: post
title: "[C#] Lambda花式應用噁爛寫法（跨UI委派秒幹、多線程處理...etc）"
date: '2015-04-20T12:45:00.002-07:00'
author: 聖豪馬
tags:
- Lambda
- CSharp
modified_time: '2015-04-20T12:45:33.532-07:00'
blogger_id: tag:blogger.com,1999:blog-1335849442109808564.post-4486867833185796857
blogger_orig_url: http://helloadr.blogspot.com/2015/04/c-lambdauietc.html
---

為啥會有這篇呢...因為最近寫太多C# 突然發現Lambda對程式碼減化太有幫助了=...=<br />為了怕哪天老人癡呆忘了這些噁心的花式寫法，就開一篇Blog文紀錄了<br /><br />以前在寫多線程,可能得這麼寫： <br /><pre class="brush: cpp;">void Func() {/*多線程要做的事情*/}<br /><br />//接著呼叫：<br />Thread nThread = new Thread(Func);<br />nThread.Start();<br /></pre><br />但今天用Lambda可以改寫： <br /><pre class="brush: cpp;">Thread nThread = new Thread(() =&gt; {/*多線程要做的事情*/});<br />nThread.Start();<br /></pre><br />甚至在噁心點寫的寫法： <br /><pre class="brush: cpp;">new Thread(() =&gt; {/*多線程要做的事情*/}).Start();<br /></pre>簡單來說Lambda的形式可拆解成： ()是指你的函數參數列、然後可用=&gt;代表你要接的Lambda陳述句/塊，最後用{}把事情包起來。 在來就是比較討厭的C#內要做跨UI線程操控UI上物件，會有跨UI安全性線程問題， 所以一般會額外寫個委派函數，然後請求UI Thread去處理這個委派函數請求，才能控制 這樣往往可能只用一兩次的委派函數，卻要占用一個篇幅去寫委派函數 <br />先看看正常的跨UI委派寫法： <br /><pre class="brush: cpp;">   private delegate void nCallback(string ContentText); <br />    public void n(string ContentText)<br />    {<br />        if (this.InvokeRequired)<br />        {<br />            nCallback obj = new nCallback(n);<br />            this.Invoke(obj, new object[] { ContentText });<br />            return;<br />        }<br />        this.Text = ContentText;<br />    }<br />    //調用時呼叫n("str")<br /></pre><br /><br />就可以改寫成： <br /><pre class="brush: cpp;">this.Invoke(new Action(() =&gt; { this.Text = "Str"; })); <br /></pre><br /><br />又因為=&gt;後面可接陳述塊或者陳述句，所以可以寫這樣： <br /><pre class="brush: cpp;">this.Invoke(new Action(() =&gt; this.Text = "Str" )); <br /></pre>